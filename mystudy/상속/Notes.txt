1. 상속을 하게되면 자식 클래스의 생성자의 호출이 완료되기 이전에 반드시 부모 클래스의 생성자가 호출이 완료된다.
2. this 키워드는 현재 메서드가 정의된 클래스를 의미한다. 
3. super 키워드는 현재 메서드가 정의된 클래스의 한단계 부모 클래스를 의미한다.
4. 여기서 this(), super()처럼 괄호를 사용하게되면 생성자를 의미하게 된다.(괄호안에는 매개변수가 들어갈 수 있다.-> 생성자의 종류에 따라가능)
5. this, super키워드를 사용해 해당클래스의 메서드 또는 멤버변수를 사용하고 싶다면 점(".")을 사용하면된다. ==> 주의, 맴버변수는 지역변수가 아님
6. 1번에서 언급한 부모생성자의 호출은 일반클래스의 객체 생성시 해당 객체의 기본 생성자가 자동으로 호출되는것과 동일한 개념으로 생각하면된다. (명시하지 않으면 생략되었다는 의미..)
	상속받은 객체 호출시 해당 클래스의 생성자가 호출되면서 부모클래스의 생성자가 동일한 개념으로 호출된다.(명시하는 것이 가능하지만 명시하지않으면 기본생성자가 자동호출됨)
7. 기본생성자의 자동호출은 명시하지않아 생성자의 호출을 명시적으로 명령받지 못했을 때만 호출된다.
	Ex) Child child = new Child("매개변수 생성자");
	의 형식으로 매개변수 생성자를 호출하는 방식으로 선언하였을 때,
	public Child(String name) {
		super("부모 매개변수");
		this.name = name;
		System.out.println("자식 매개변수 : " + this.name);
	}
	이 생성자가 호출되는데 super("부모 매개변수")로 인해 부모 생성자가 명시적으로 호출되었으므로 부모 기본생성자는 자동호출되지않는다.
	 


 

오버라이딩을 한다음에 this 키워드 사용해보기
* 오버라이딩은 참조하는 개념이 아닌 새로 정의해서 사용하는 개념이다.
==> 일반적으로 객체 생성을하면 해당 객체를 참조하게 되는데 된다.B클래스에서 객체를 생성했을때, 객체가 참조한 것이 A클래스 라고 하자.
	B클래스에서 객체를 생성하면  Heap영역에 할당되고, Stack영역에 Heap영역에 생성된 Object타입(현재 A클래스 타입) 데이터의 참조값이 할당된다.
	이것의 의미는 B클래스에서 객체를 생성할 때 참조타입을 복사하여 새로 만드는 것이아닌 가져다 사용하는(참조) 의미로 해석해야 한다. 
	Ex)
	public class 메모리 {
		Child 메모리	 	= new Child();
		Child 메모리2  	= new Child();
		Child 메모리3 	= new Child();
	}
	이와 같이 선언 했다고 하면 Child를 3번 참조했다고 해서 Child에 있는 메서드가 3개씩 존재하는것이 아닌 Stack영역에 하나의 Child 참조값이 생기는 것이다.
	하지만, 오버라이딩의 개념은 다르다. 명시적으로 재정의(복사)를 하는 개념이기 때문에 새로운 메서드가 메모리에 할당된다.
	메모리, 메모리2, 메모리3이 Heap에 저장된 위치는 전부 다르다.
	
	 
주소값 Vs 참조값
C에서는 new연산자를 사용하여 메모리를 생성하면 해당 메모리의 주소를 갖게되어 주소값을 할당받지만
자바는 주소에 연결된 참조값을 갖게된다. (참조변수에는 참조값이라는 정수값이 할당된다.)



 
 
 
MotorCycle m = new MotorCycle(); 
    MotorCycle: 새로운 사용자 정의 데이터 타입 
    m: MotorCycle 데이터 타입으로 선언한 참조변수(객체변수) 
    new: 메모리를 생성하는 연산자, 참조값을 리턴합니다. 
    MotorCycle(): 메모리 생성 후 해당 메모리의 초기화 작업을 담당하는 생성자 



